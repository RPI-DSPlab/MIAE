from typing import List, Tuple, Dict, Optional

import numpy as np
from matplotlib import pyplot as plt
from matplotlib_venn import venn3_unweighted, venn3, venn2_unweighted, venn2

from MIAE.miae.eval_methods.prediction import Predictions, pred_tp_intersection


def plot_venn_single(pred_list: List[Predictions], graph_title: str, save_path: str):
    """
    Plot Venn diagrams for a single attack with 3 different seeds including both unweighted and weighted Venn diagrams.
    :param pred_list: list of Predictions objects
    :param graph_title: title of the graph
    :param save_path: path to save the graphs
    """
    plt.figure(figsize=(14, 7), dpi=300)
    attacked_points = {pred.name: set() for pred in pred_list}
    for pred in pred_list:
        attacked_points[pred.name] = set(np.where((pred.predictions_to_labels() == pred.ground_truth_arr))[0].tolist())

    plt.text(0.1, 0.1 + len(pred_list) * 0.03, "Accuracy of each seed:", fontsize=10, transform=plt.gcf().transFigure)
    for i, pred in enumerate(pred_list):
        plt.text(0.11, 0.1 + i * 0.03, f"{pred.name}: {pred.accuracy():.4f}", fontsize=10,
                 transform=plt.gcf().transFigure)
    plt.axis('off')

    venn_sets = tuple(attacked_points[pred.name] for pred in pred_list)
    venn_labels = [pred.name for pred in pred_list]
    circle_colors = ['red', 'blue', 'green', 'purple', 'orange']

    # Plotting unweighted Venn diagram
    plt.subplot(1, 2, 1, aspect='equal')
    venn3_unweighted(subsets=venn_sets, set_labels=venn_labels, set_colors=circle_colors)
    plt.title("Unweighted")

    # Plotting weighted Venn diagram
    plt.subplot(1, 2, 2, aspect='equal')
    venn3(subsets=venn_sets, set_labels=venn_labels, set_colors=circle_colors)
    plt.title("Weighted")

    plt.suptitle(graph_title, fontweight='bold')
    plt.savefig(f"{save_path}.png", dpi=300)


def find_pairwise_preds(pred_list: List[Predictions]) -> List[Tuple[Predictions, Predictions]]:
    """
    Find all possible pairs of predictions in the given list.
    :param pred_list: list of Predictions
    :return: list of tuples, each containing a pair of Predictions
    """
    pairs = []
    n = len(pred_list)
    for i in range(n):
        for j in range(i + 1, n):
            pairs.append((pred_list[i], pred_list[j]))
    return pairs


def plot_venn_pairwise(pred_pair_list: List[Tuple[Predictions, Predictions]], graph_title: str, save_path: str):
    """
    Plot Venn diagrams for each pair of predictions in the given list including both unweighted and weighted Venn diagrams.
    :param pred_pair_list: list of tuples, each containing a pair of Predictions objects
    :param graph_title: title of the graph
    :param save_path: path to save the graphs
    """
    plt.figure(figsize=(14, 7), dpi=300)

    for idx, pair in enumerate(pred_pair_list):
        pred_1, pred_2 = pair
        attacked_points_1 = set(np.where((pred_1.pred_arr == 1) & (pred_1.ground_truth_arr == 1))[0])
        attacked_points_2 = set(np.where((pred_2.pred_arr == 1) & (pred_2.ground_truth_arr == 1))[0])

        # Plotting unweighted Venn diagram
        plt.subplot(1, 2, 1, aspect='equal')
        circle_colors = ['red', 'blue', 'green', 'purple', 'orange']
        venn2_unweighted(subsets=(attacked_points_1, attacked_points_2), set_labels=(pred_1.name, pred_2.name),
                         set_colors=circle_colors)
        plt.title("Unweighted")

        # Plotting weighted Venn diagram
        plt.subplot(1, 2, 2, aspect='equal')
        venn2(subsets=(attacked_points_1, attacked_points_2), set_labels=(pred_1.name, pred_2.name),
              set_colors=circle_colors)
        plt.title("Weighted ")

        plt.subplots_adjust(hspace=0.1)
        plt.tight_layout()  # Adjust layout to prevent overlapping
        plt.suptitle(f"{graph_title}: {pred_1.name} vs {pred_2.name}", fontweight='bold')
        plt.savefig(f"{save_path}_{pred_1.name}_vs_{pred_2.name}.png", dpi=300)
        plt.close()


def data_process_for_venn(pred_dict: Dict[str, List[Predictions]], threshold: Optional[float] = 0,
                          target_fpr: Optional[float] = 0) -> List[Predictions]:
    """
    Process the data for the Venn diagram: get the pred_list
    :param pred_dict: dictionary of Predictions from different attacks, key: attack name, value: list of Predictions of different seeds
    :param threshold: threshold for the comparison (only used when the graph is generated by threshold otherwise None)
    :param target_fpr: target FPR for the comparison (only used when the graph is generated by FPR otherwise None)
    :param name: name of the attack (only used when we want to compare a single attack with different seeds)
    """
    if len(pred_dict) < 2:
        raise ValueError("There is not enough data for comparison.")

    if threshold != 0:
        result_or = []
        result_and = []
        counter = 0
        for attack, pred_obj_list in pred_dict.items():
            counter += 1

            common_tp_or, common_tp_and = pred_tp_intersection(pred_obj_list)
            result_or.append(common_tp_or)
            result_and.append(common_tp_and)

    elif target_fpr != 0:
        adjusted_pred_dict = {}
        result_or = []
        result_and = []
        for attack, pred_obj_list in pred_dict.items():
            adjusted_pred_list = []
            for pred in pred_obj_list:
                adjusted_pred_arr = pred.adjust_fpr(target_fpr)
                name = pred.name.split('_')[0]
                adjusted_pred_obj = Predictions(adjusted_pred_arr, pred.ground_truth_arr, name)
                adjusted_pred_list.append(adjusted_pred_obj)
            adjusted_pred_dict[attack] = adjusted_pred_list

        for attack, adjusted_list in adjusted_pred_dict.items():
            common_tp_or, common_tp_and = pred_tp_intersection(adjusted_list)
            result_or.append(common_tp_or)
            result_and.append(common_tp_and)

    else:
        raise ValueError("Either threshold or target_fpr should be provided.")

    return result_or, result_and


def plot_venn_diagram(pred_or: List[Predictions], pred_and: List[Predictions], title: str, save_path: str):
    """
    plot venn diagrams based on the goal including both unweighted and weighted venn diagrams.
    :param pred_or: list of Predictions for the 'pred_or' set
    :param pred_and: list of Predictions for the 'pred_and' set
    :param title: title of the graph
    :param save_path: path to save the graph
    """
    attacked_points_or = {pred.name: set() for pred in pred_or}
    attacked_points_and = {pred.name: set() for pred in pred_and}
    plt.figure(figsize=(16, 14), dpi=300)

    venn_sets_or = []
    venn_labels_or = [pred.name for pred in pred_or]
    for pred in pred_or:
        attacked_points_or[pred.name] = set(np.where((pred.pred_arr == 1) & (pred.ground_truth_arr == 1))[0])
        venn_sets_or.append(attacked_points_or[pred.name])

    venn_sets_and = []
    venn_labels_and = [pred.name for pred in pred_and]
    for pred in pred_and:
        attacked_points_and[pred.name] = set(np.where((pred.pred_arr == 1) & (pred.ground_truth_arr == 1))[0])
        venn_sets_and.append(attacked_points_and[pred.name])

    gs = plt.GridSpec(2, 2, width_ratios=[1, 1], height_ratios=[1, 1])
    for i, (venn_sets, venn_labels, venn_title) in enumerate([(venn_sets_or, venn_labels_or, "Union"),
                                                              (venn_sets_and, venn_labels_and, "Intersection")]):
        for j, (venn_function, title_suffix) in enumerate(
                [(venn3_unweighted if len(pred_or) == 3 else venn2_unweighted, "Unweighted"),
                 (venn3 if len(pred_or) == 3 else venn2, "Weighted")]):
            ax = plt.subplot(gs[i, j], aspect='equal')  # Use GridSpec to set aspect ratio
            circle_colors = ['red', 'blue', 'green', 'purple', 'orange']
            venn_function(subsets=venn_sets, set_labels=venn_labels, set_colors=circle_colors)
            plt.title(f"{venn_title} \n {title_suffix}")

            if i == 0:
                plt.ylabel("Union")
            else:
                plt.ylabel("Intersection")

            if j == 0:
                plt.xlabel("Unweighted")
            else:
                plt.xlabel("Weighted")

    plt.suptitle(title, fontweight='bold')
    plt.tight_layout()  # Adjust layout to prevent overlapping
    plt.savefig(f"{save_path}.png", dpi=300)


def plot_venn_diagram_pairwise(pred_pair_list: List[Tuple[Predictions, Predictions]], graph_title: str, save_path: str):
    """
    Plot Venn diagrams for each pair of predictions in the given list.
    :param pred_pair_list: list of tuples, each containing a pair of Predictions objects
    :param graph_title: title of the graph
    :param save_path: path to save the graphs
    """
    plt.figure(figsize=(8, 8), dpi=300)
    for idx, pair in enumerate(pred_pair_list):
        pred_1, pred_2 = pair
        attacked_points_1 = set(np.where((pred_1.pred_arr == 1) & (pred_1.ground_truth_arr == 1))[0])
        attacked_points_2 = set(np.where((pred_2.pred_arr == 1) & (pred_2.ground_truth_arr == 1))[0])
        circle_colors = ['#EB001B', '#F79E1B']
        venn2_unweighted(subsets=(attacked_points_1, attacked_points_2), set_labels=(pred_1.name, pred_2.name),
                         set_colors=circle_colors)
        plt.title(f"{graph_title}: {pred_1.name} vs {pred_2.name}")
        plt.savefig(f"{save_path}_{pred_1.name}_vs_{pred_2.name}.png", dpi=300)
        plt.close()
